[Info]
Type:AdvDupe File
Creator:"Tolyzor"
Date:03/04/11
Description:"by Tolyzor"
Entities:9
Constraints:12
[More Information]
FileVersion:0.84
AdvDupeVersion:1.85
AdvDupeToolVersion:1.9
AdvDupeSharedVersion:1.72
SerialiserVersion:1.4
WireVersion:2396 (EXPORTED)
Time:09:06 PM
Head:312
HoldAngle:0,80.356,0
HoldPos:46.8183,-19.9437,-5.96272
StartPos:-2320.25,4791.42,248.031
[Save]
Entities:1F29BC68{Y:2=Y:28;Y:3=A:90,-90.0005,180;Y:4=V:-19.9436,5.96289,46.8183;Y:5=N:0;Y:7=T:1F28FC68;Y:9=Y:8;Y:17=T:1F294FD8;}1A5E32E8{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1F290478{N:0=T:1F297D68;}1B1775B0{Y:64=T:1B171A90;S:"Src"=N:297;Y:65=Y:180;Y:66=V:0.765625,2.83181,2.33103;Y:15=T:1B176D40;Y:68=Y:67;Y:69=V:1.25098,0.369147,0.73193;Y:70=N:0;}1B171A90{;}1F290328{Y:2=Y:1;Y:3=A:45,180,-90;Y:4=V:-43.668,1.25635,46.58;Y:5=N:0;Y:7=T:1F295A28;Y:9=Y:8;Y:17=T:1F29BA88;}1B176D40{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1BE655B0{N:-1;N:-1;}1A5E3858{;}1A5EA428{Y:64=T:1A5EB8C8;S:"Src"=N:298;Y:65=Y:49;Y:66=V:-0.56543,-0.769525,0.731452;Y:15=T:1A5E15A8;Y:68=Y:67;Y:69=V:-0.100586,-0.280999,0.731448;Y:70=N:0;}1F2925A8{Y:3=A:88.732,-91.492,355.621;Y:4=V:-2.15356,-0.287598,58.6923;Y:6=B:t;}1A5E4C08{Y:64=T:1A5E6CA8;S:"Src"=N:298;Y:65=Y:76;Y:66=V:-0.790039,0.0441961,0.731445;Y:15=T:1A5ECC48;Y:68=Y:67;Y:69=V:-0.951172,0.206794,0.731443;Y:70=N:0;}1A5EB8C8{;}1B171B20{;}1A5E1C68{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}1F28E618{Y:15=T:1F28C308;}1A5ED728{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1B172C30{Y:3=A:87.5284,-89.8406,357.839;Y:4=V:-8.07446,-0.279785,64.6202;Y:6=B:t;}1A5E15A8{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1BE74730{N:0;N:0;}1F296B68{Y:24=N:0;Y:32=T:1F291468;}1A5E9618{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}203FA458{Y:41;Y:56;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:57;Y:41;Y:41;Y:57;Y:41;}1F295A28{N:0=T:1F28D328;}1B176B90{Y:78=T:1B16FF30;}1B1708C0{Y:64=T:1B1704D0;S:"Src"=N:298;Y:65=Y:76;Y:66=V:-0.239258,0.531501,0.73144;Y:15=T:1B176560;Y:68=Y:67;Y:69=V:-0.0419922,0.855964,0.731438;Y:70=N:0;}1F29BDB8{Y:3=A:90,-90.0005,180;Y:4=V:-19.9436,5.96289,46.8183;Y:6=B:t;}1F29AF18{Y:50;Y:176;Y:39;S:"T";Y:52;Y:48;}1B177400{;}1A5EAA88{Y:24=N:0;Y:32=T:1A5E5BF8;Y:16=T:1A5E8688;}1A5E2238{Y:64=T:1A5E16F8;S:"Src"=N:311;Y:65=Y:74;Y:66=V:1.98247,-0.0881441,1.09668;Y:15=T:1A5EC348;Y:68=Y:67;Y:69=V:-0.0368018,1.06794,0.731609;Y:70=N:0;}1EA48370{;}1BE6B070{N:90;N:170;N:90;}1A5DFFE8{Y:64=T:1A5DF748;S:"Src"=N:313;Y:65=Y:71;Y:66=V:1.73,-31.12,0.33;Y:15=T:1A5E7848;Y:68=Y:72;Y:69=V:1.22,1.65,0.73;Y:70=N:0;}1A5EE748{;}1F292158{Y:13=N:5000;}1F298BD8{Y:15=T:1F2995F8;}1B173F50{N:0=T:1B172C30;}1A5EB418{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1A5E4338{;}1EA3C550{;}1F295B48{Y:12=T:1F2925D8;Y:14=T:1F28F2D8;Y:16=T:1F28E618;}1F29BA58{Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:57;Y:41;Y:41;Y:41;Y:41;Y:41;Y:57;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:41;Y:57;Y:41;Y:41;Y:41;Y:41;Y:57;Y:41;Y:41;Y:41;}1F294D38{Y:3=A:-45.0001,179.999,269.999;Y:4=V:-43.6667,0.03125,46.8196;Y:6=B:t;}1A5E6CA8{;}1BE6E5B0{N:0;N:0;}1A5E8328{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1B16FF30{Y:50=T:1B16F8D0;Y:176=T:1B1775B0;Y:39=T:1B172F30;S:"T"=T:1B171D30;Y:52=T:1B1708C0;Y:48=T:1B172BD0;}1F2960B8{Y:26=Y:25;}1F29AA08{N:0=T:1F294D38;}1F296C88{Y:13=N:1500;}1A5EBF88{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1F2903B8{Y:7=T:1F290478;Y:3=A:89.9803,90.0277,180;Y:4=V:35.7842,-0.159668,55.4541;Y:2=Y:30;Y:17=T:1F298FF8;Y:9=Y:33;Y:5=N:0;}203F6FD8{T:203F7B78;T:203FA458;}1BE6A0B0{Y:44=N:0;Y:79=N:0;Y:80=S:"";Y:81=T:1BE74730;S:"Ft"=N:0.0625;Y:82=S:"";Y:83=T:1BE72390;S:"Sy1"=N:0;Y:84=S:"";Y:85=S:"";Y:86=T:1BE734A0;Y:87=N:100;Y:88=T:1BE6ADA0;Y:89=N:0;Y:90=N:0;Y:91=S:"";Y:92=S:"";Y:93=T:1BE6FF30;Y:94=S:"";Y:95=N:0;Y:49=N:-600;Y:47=N:0;Y:96=S:"";Y:97=N:0;Y:98=N:0;Y:99=S:"";Y:100=N:0;Y:40=T:1BE655B0;Y:101=S:"";Y:102=S:"";Y:54=T:1BE6C720;Y:103=S:"";Y:39=N:0;Y:104=T:1BE72000;Y:105=T:1BE6D1D0;Y:51=N:0;Y:37=N:1;Y:106=N:0;Y:107=T:1BE6AFE0;Y:108=T:1BE71F40;Y:109=T:1BE6F270;Y:110=S:"";Y:111=S:"";Y:50=N:2;Y:112=N:0;Y:113=N:125;Y:46=N:0;Y:114=T:1BE6B070;Y:115=N:0;Y:35=N:0;Y:116=T:1BE67CE0;Y:117=T:1BE6E160;Y:36=N:0;Y:118=N:100;Y:119=T:1BE68A00;Y:120=T:1BE68160;Y:121=T:1BE6DE00;Y:122=N:0;Y:123=N:314;Y:124=T:1BE74100;Y:125=N:0;S:"Lb"=N:2.2046226218488;Y:126=N:0;Y:127=N:0;Y:128=S:"";S:"Sf"=N:3;Y:129=N:200;Y:130=T:1BE6E0A0;S:"RSD"=T:1BE70DA0;Y:53=N:63.466520578553;Y:55=N:66.566669;Y:131=N:45;Y:132=N:100;Y:133=T:1BE75300;Y:134=N:360;S:"I"=N:0;Y:135=N:0;Y:136=S:"";Y:137=T:1BE713A0;Y:138=S:"";S:"Sx1"=N:0;Y:139=N:0;Y:140=T:1BE6E5B0;Y:52=N:4000;S:"M"=N:0.01905;Y:45=N:0;Y:141=N:0;Y:38=N:0;Y:142=N:0;Y:143=T:1BE74160;S:"Sy2"=N:0;Y:144=N:0;Y:145=S:"";Y:146=S:"";Y:147=N:0;Y:148=S:"";Y:149=S:"";Y:150=N:0;S:"Sx2"=N:0;Y:151=T:1BE6F780;Y:152=N:0;Y:153=T:1BE65C40;Y:154=N:0;Y:48=N:50;}1BE6E0A0{N:0;N:0;}1B175D50{Y:15=T:1B171FA0;}1A5E1878{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1A5E49C8{;}1F294FD8{Y:12=T:1F298188;Y:14=T:1F292158;}1BE74100{N:170;N:90;N:90;}1EA3BB00{Y:44=N:0;Y:157=N:0;S:"Kp"=N:0;Y:181=N:0;Y:161=N:0;Y:162=N:0;Y:182=N:0;Y:183=N:0;Y:163=N:0;Y:184=N:0;Y:168=N:0;S:"Kd"=N:0;Y:169=N:1;Y:185=N:0;Y:156=N:0;Y:186=T:1EA3C550;Y:187=N:0;Y:188=N:0;Y:158=N:0;Y:189=N:0;Y:190=N:0;Y:165=T:1EA44F80;Y:166=N:0;S:"Dir"=N:0;Y:54=N:0;Y:171=N:0;Y:75=T:1EA411D0;Y:51=N:0;Y:174=N:0;Y:172=N:0;Y:46=N:0;Y:175=N:0;S:"RSD"=N:0;Y:191=N:0;Y:192=N:0;Y:170=N:9000000000;Y:50=N:2;Y:73=N:0;Y:160=N:0;Y:193=N:0;Y:194=N:0;Y:195=S:"";Y:45=N:0;Y:196=N:0;Y:197=N:0;Y:159=T:1EA48370;S:"I"=N:0;Y:198=N:0;Y:199=N:3;Y:52=N:63.466520578553;Y:39=N:0;Y:164=N:0;Y:97=N:-0;Y:167=N:0;Y:200=N:0;S:"P"=N:0;Y:201=N:0;Y:202=N:0;Y:203=N:0;S:"T"=N:66.566669;Y:204=N:50;Y:205=N:0;S:"D"=N:0;Y:173=N:1;Y:101=S:"";Y:206=N:0;Y:77=T:1EA430C0;Y:207=N:0;S:"Ki"=N:0;Y:48=N:50;}1B172F30{Y:64=T:1B177400;S:"Src"=N:299;Y:65=Y:39;Y:66=V:-1.51465,0.219489,0.731443;Y:15=T:1B171EB0;Y:68=Y:67;Y:69=V:1.30371,-0.0214777,0.731934;Y:70=N:0;}1B171D30{Y:64=T:1B170260;S:"Src"=N:298;Y:65=Y:55;Y:66=V:-0.245117,0.693854,0.731439;Y:15=T:1B171CA0;Y:68=Y:67;Y:69=V:0.603516,0.206794,0.731932;Y:70=N:0;}1A5DF748{;}1BE6D1D0{N:0;N:0;}1F2995F8{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}1F292F38{Y:44;Y:156;Y:157;Y:45;Y:46;Y:158;Y:159;Y:160;Y:161;Y:162;Y:163;Y:164;Y:165;Y:166;Y:167;Y:168;S:"Kp";S:"Kd";S:"Dir";Y:169;Y:170;Y:171;Y:75;Y:172;Y:173;Y:51;Y:174;Y:77;Y:175;S:"Ki";Y:73;}203F2FB8{Y:15=T:203F8D78;}1BE6E160{N:0;N:0;}203F7B78{Y:44;S:"S";Y:45;Y:46;Y:47;Y:48;Y:49;Y:50;Y:51;S:"RSD";Y:52;Y:53;Y:54;Y:55;}1BE70DA0{;}1B170260{;}1EA44F80{;}1BE6F270{N:0;N:0;}203F8D78{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}203F37F8{N:0=T:203F4C08;}H1F2965C8{N:306=T:1F290328;N:310=T:1F28CE78;N:311=T:1F2944C8;N:312=T:1F29BC68;N:313=T:1F2903B8;N:299=T:1A5E38E8;N:300=T:1B175C90;N:297=T:1F29B488;N:298=T:203FA938;}1BE6DE00{N:0;N:0;}203F58C8{N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;N:0.015625;N:0.0146484375;}203F4728{Y:214=N:15449.924804688;Y:215=N:15449.939453125;Y:49=N:-600;Y:216=N:1;Y:217=N:0;Y:76=N:63.466520578553;Y:51=N:4000;Y:50=N:2;Y:218=T:203F58C8;Y:162=N:102;Y:219=N:0;Y:55=N:66.566669;}203F9DC8{;}203FA758{Y:78=T:203F9DC8;}203F6198{Y:24=N:0;Y:32=T:203FA758;Y:16=T:203F2FB8;}1A5ECC48{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1B171730{;}1A5E8688{Y:15=T:1A5E1C68;}1BE65C40{N:0;N:0;}1A5EE6B8{;}1A5EC348{S:"a"=N:255;S:"r"=N:255;S:"g"=N:238;S:"b"=N:0;}1B173020{Y:50;Y:51;Y:49;Y:76;Y:55;}1B177190{T:1B173020;T:1B1764D0;}1B16FE40{;}203F4C08{Y:3=A:87.5284,-89.8406,357.839;Y:4=V:-8.07446,-0.279785,40.8927;Y:6=B:t;}1F28D328{Y:3=A:45,180,270;Y:4=V:-43.668,1.25635,46.58;Y:6=B:t;}203FA938{Y:7=T:203F37F8;Y:9=Y:34;Y:3=A:87.5284,-89.8406,-2.16077;Y:43=T:1B177190;Y:58=T:1B177340;Y:60=Y:212;Y:4=V:-8.07446,-0.279785,40.8927;Y:2=Y:61;Y:63=Y:213;Y:17=T:203F6198;Y:155=T:203F4728;Y:5=N:0;}1F291468{Y:211=N:310;}1B171FA0{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}1F292458{N:0=T:1F28C458;}1BE75300{N:0;N:0;}1F29B488{Y:208=B:t;Y:3=A:90,89.9995,180;Y:4=V:-19.9226,-0.249512,64.6366;Y:5=N:0;Y:7=T:1F292458;Y:9=Y:209;Y:2=Y:210;Y:17=T:1F296B68;}1F293CB8{Y:13=N:1500;}1A5E24A8{;}1F297D68{Y:3=A:89.9803,90.0277,180;Y:4=V:35.7842,-0.159668,55.4541;Y:6=B:t;}1BE6FF30{;}1A5E7F98{Y:64=T:1A5EE6B8;S:"Src"=N:298;Y:65=Y:55;Y:66=V:-0.0654297,1.01783,0.731436;Y:15=T:1A5E0168;Y:68=Y:67;Y:69=V:0.392578,0.369147,0.731442;Y:70=N:0;}1BE72390{N:0;N:150;N:0;}1B174CD0{Y:24=N:0;Y:32=T:1B176B90;Y:16=T:1B175D50;}1BE734A0{N:150;N:0;N:0;}1EA411D0{;}203FAAE8{T:203F70C8;T:203F9FD8;}203F9FD8{Y:41;Y:41;Y:41;Y:41;Y:41;Y:42;}1F28C458{Y:3=A:90,89.9995,180;Y:4=V:-19.9226,-0.249512,64.6366;Y:6=B:t;}1F2925D8{Y:11=Y:19;}1A5E5268{Y:64=T:1A5E4338;S:"Src"=N:300;Y:65=Y:51;Y:66=V:0.280273,0.0444403,0.731933;Y:15=T:1A5EC288;Y:68=Y:67;Y:69=V:0.0644532,-0.118157,0.731446;Y:70=N:0;}1B175E40{;}1B172BD0{Y:64=T:1B175E40;S:"Src"=N:311;Y:65=Y:74;Y:66=V:0.285156,-0.878163,1.14112;Y:15=T:1B173170;Y:68=Y:67;Y:69=V:0.442383,1.01783,0.730459;Y:70=N:0;}1B177340{T:1B171730;T:1B171B20;}1B1704D0{;}1B171CA0{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1B171EB0{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1A5E07F8{;}1A5ECA68{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1A5E1368{Y:64=T:1A5E66D8;S:"Src"=N:300;Y:65=Y:73;Y:66=V:1.25195,-0.606439,0.731939;Y:15=T:1A5E1878;Y:68=Y:67;Y:69=V:-0.951172,0.206794,0.731443;Y:70=N:0;}1A5EE868{Y:44=T:1A5E29E8;S:"S"=T:1A5DFFE8;Y:45=T:1A5E7F38;Y:46=T:1A5E8F88;Y:47=T:1A5E1368;Y:48=T:1A5E2238;Y:49=T:1A5EA428;Y:50=T:1A5ED638;Y:51=T:1A5E5268;S:"RSD"=T:1A5E5B08;Y:52=T:1A5EC0A8;Y:53=T:1A5E4C08;Y:54=T:1A5E17E8;Y:55=T:1A5E7F98;}1F28CE78{Y:2=Y:18;Y:3=A:-45.0001,179.999,-90.001;Y:4=V:-43.6667,0.03125,46.8196;Y:5=N:0;Y:7=T:1F29AA08;Y:9=Y:8;Y:17=T:1F295B48;}1BE713A0{N:0;N:0;}1F28F2D8{Y:13=N:1500;}1F28F428{Y:24=N:0;Y:27=T:1F2960B8;}1A5E38E8{Y:7=T:1A5E66A8;Y:9=Y:34;Y:3=A:87.5284,-89.8406,-2.16077;Y:43=T:203FAAE8;Y:58=T:203F6FD8;Y:60=Y:59;Y:4=V:-8.07446,-0.279785,52.756;Y:2=Y:61;Y:63=Y:62;Y:17=T:1A5EAA88;Y:155=T:1BE6A0B0;Y:5=N:0;}1B175C90{Y:7=T:1B173F50;Y:9=Y:34;Y:3=A:87.5284,-89.8406,-2.16074;Y:43=T:1F295D28;Y:58=T:1F28FC98;Y:60=Y:178;Y:4=V:-8.07446,-0.279785,64.6202;Y:2=Y:61;Y:63=Y:179;Y:17=T:1B174CD0;Y:155=T:1EA3BB00;Y:5=N:0;}1A5E7F38{Y:64=T:1A5E24A8;S:"Src"=N:300;Y:65=Y:45;Y:66=V:-0.368164,-0.443597,0.731449;Y:15=T:1A5ED728;Y:68=Y:67;Y:69=V:0.220703,0.531501,0.73144;Y:70=N:0;}1EA430C0{;}1A5EC288{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1F28C308{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}1F298158{Y:31=B:t;}1A5E5BF8{Y:78=T:1A5EE868;}1B173B30{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}203F70C8{Y:35;Y:36;Y:37;Y:38;Y:39;Y:40;}1BE68160{N:0;N:0;}1BE67CE0{N:0;N:0;}1A5E17E8{Y:64=T:1A5EE748;S:"Src"=N:300;Y:65=Y:77;Y:66=V:0.442383,0.85572,0.731438;Y:15=T:1A5EB418;Y:68=Y:67;Y:69=V:0.392578,0.369147,0.731442;Y:70=N:0;}1A5E0A98{;}1BE6AFE0{N:0;N:0;N:150;}1F28FC98{T:1F29AF18;T:1F2977F8;}1A5E7848{S:"a"=N:255;S:"b"=N:255;S:"g"=N:255;S:"r"=N:255;}1F2944C8{Y:7=T:1F290958;Y:3=A:88.732,-91.492,-4.37881;Y:4=V:-2.15356,-0.287598,58.6923;Y:5=N:0;Y:21=T:1F291E58;Y:9=Y:22;Y:2=Y:23;Y:17=T:1F28F428;}1B1764D0{Y:41;Y:41;Y:41;Y:41;Y:41;}1F295D28{T:1F292F38;T:1F29BA58;}1BE72000{N:0;N:0;}1B176560{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1BE6F780{;}1A5E5B08{Y:64=T:1A5E3858;S:"Src"=N:300;Y:65=Y:75;Y:66=V:-0.366211,0.369147,0.731442;Y:15=T:1A5ECA68;Y:68=Y:67;Y:69=V:0.731445,0.369147,0.731442;Y:70=N:0;}1A5E66A8{N:0=T:1A5EB718;}1F290958{N:0=T:1F2925A8;}1BE74160{N:90;N:90;N:170;}1A5E0168{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1F298FF8{Y:32=T:1F298158;Y:14=T:1F296C88;}1F28FC68{N:0=T:1F29BDB8;}1F291E58{Y:20;}1A5E29E8{Y:64=T:1A5E0EE8;S:"Src"=N:300;Y:65=Y:44;Y:66=V:0.442383,0.531501,0.73144;Y:15=T:1A5EBF88;Y:68=Y:67;Y:69=V:0.0517578,0.531501,0.731929;Y:70=N:0;}1A5E8F88{Y:64=T:1A5E0A98;S:"Src"=N:300;Y:65=Y:46;Y:66=V:-0.527344,0.69361,0.731927;Y:15=T:1A5E8328;Y:68=Y:67;Y:69=V:-0.12793,1.17994,0.731435;Y:70=N:0;}1F2977F8{Y:41;Y:177;Y:41;Y:41;Y:41;Y:41;}1BE68A00{N:0;N:0;}1A5E66D8{;}1A5EC0A8{Y:64=T:1A5E07F8;S:"Src"=N:298;Y:65=Y:51;Y:66=V:-0.59375,-0.118402,0.731446;Y:15=T:1A5E9618;Y:68=Y:67;Y:69=V:-0.104492,-0.118402,0.731446;Y:70=N:0;}1BE71F40{N:0;N:0;}1F29BA88{Y:12=T:1F28F518;Y:14=T:1F293CB8;Y:16=T:1F298BD8;}1BE6C720{;}1B173170{S:"a"=N:255;S:"b"=N:0;S:"g"=N:238;S:"r"=N:255;}1A5EB718{Y:3=A:87.5284,-89.8406,357.839;Y:4=V:-8.07446,-0.279785,52.756;Y:6=B:t;}1A5E16F8{;}1F298188{Y:11=Y:29;}1F28F518{Y:11=Y:10;}1BE6ADA0{N:0;N:0;}1A5ED638{Y:64=T:1A5E49C8;S:"Src"=N:298;Y:65=Y:50;Y:66=V:0.498047,1.3418,0.731433;Y:15=T:1A5E32E8;Y:68=Y:67;Y:69=V:-0.791992,0.69361,0.731439;Y:70=N:0;}1A5E0EE8{;}1B16F8D0{Y:64=T:1B16FE40;S:"Src"=N:298;Y:65=Y:50;Y:66=V:1.125,0.0444403,0.731445;Y:15=T:1B173B30;Y:68=Y:67;Y:69=V:0.603516,0.531501,0.731929;Y:70=N:0;}
Constraints:1F28E888{Y:180=T:1F291F48;Y:225=Y:226;}1F2900E8{Y:221=N:310;Y:222=N:0;}1B176F20{Y:221=N:298;Y:222=N:0;}1F299B38{Y:221=N:297;Y:222=N:0;}1F2915B8{T:1F295DE8;T:1F29C058;}1F28D3E8{T:1F296568;T:1F29C1A8;}1B173AD0{Y:208=B:t;Y:220=N:0;Y:180=T:1B174160;Y:223=B:t;Y:225=Y:224;}1F2927B8{Y:221=N:300;Y:222=N:0;}203F6CA8{Y:221=N:312;Y:222=N:0;}1F29BBD8{Y:230=V:-0.00579712,0.00806029,0.00634413;Y:221=N:312;Y:222=N:0;}1F2930E8{Y:221=N:306;Y:222=N:0;}1F28E3D8{T:1F2909E8;T:1F29B2A8;}H1A27BF18{T:203F6708;T:1F295578;T:1F28F8A8;T:1F291858;T:1F297B58;T:1F2924E8;T:1F294828;T:1F2922A8;T:1F28E888;T:1F295DB8;T:1B173AD0;T:1F29BB78;}1B174160{T:1B176F20;T:1B175DE0;}1F28C578{Y:221=N:312;Y:222=N:0;}1F29B2A8{Y:221=N:312;Y:222=N:0;}1F295DE8{Y:221=N:313;Y:222=N:0;}1F29C058{Y:221=N:312;Y:222=N:0;}1F294798{Y:221=N:312;Y:222=N:0;}1F294828{Y:208=B:t;Y:220=N:0;Y:180=T:1F28CA58;Y:223=B:t;Y:225=Y:224;}1B175DE0{Y:221=N:312;Y:222=N:0;}1F291588{Y:221=N:312;Y:222=N:0;}1F28D688{T:1F299B38;T:1F290628;}1F295DB8{Y:208=B:t;Y:220=N:0;Y:180=T:1F28C6F8;Y:223=B:t;Y:225=Y:224;}1F28CB18{Y:221=N:312;Y:222=N:0;}1F291EB8{Y:221=N:313;Y:222=N:0;}1F291F48{T:1F291EB8;T:1F28CB18;}1F29C1A8{Y:221=N:312;Y:222=N:0;}1F290628{Y:221=N:312;Y:222=N:0;}1F297B58{Y:227=N:0;Y:208=N:0;Y:228=N:0;Y:229=V:-0.00579712,0.00806029,0.00634413;Y:220=N:0;Y:180=T:1F28CF68;Y:225=Y:231;Y:232=V:0.00805752,-0.00591972,22.4878;Y:233=V:0.00805959,-0.00595071,23.4878;}1F28C6F8{T:1F2927B8;T:1F291588;}1F2922A8{Y:208=B:t;Y:220=N:0;Y:180=T:1F28D688;Y:223=B:t;Y:225=Y:224;}203F5F58{T:203F7698;T:203F6CA8;}1F292728{T:1F2930E8;T:1F2900E8;}203F6708{Y:208=B:t;Y:220=N:0;Y:180=T:203F5F58;Y:223=B:t;Y:225=Y:224;}1F291858{Y:180=T:1F28E3D8;Y:225=Y:224;Y:208=B:t;Y:220=N:0;}1F297AC8{Y:221=N:311;Y:222=N:0;}1F28C548{Y:221=N:310;Y:222=N:0;}1F2924E8{Y:180=T:1F292728;Y:225=Y:226;}1F28CA58{T:1F297AC8;T:1F28C578;}1F29BB78{Y:180=T:1F2915B8;Y:225=Y:224;Y:208=B:t;Y:220=N:0;}1F2909E8{Y:221=N:306;Y:222=N:0;}203F7698{Y:221=N:299;Y:222=N:0;}1F28CF68{T:1F2999E8;T:1F29BBD8;}1F28F8A8{Y:180=T:1F29B518;Y:225=Y:226;}1F2999E8{Y:230=V:0.00805752,-0.00591972,22.4878;Y:221=N:310;Y:222=N:0;}1F295578{Y:180=T:1F28D3E8;Y:225=Y:226;}1F29B518{T:1F28C548;T:1F294798;}1F296568{Y:221=N:306;Y:222=N:0;}
[Dict]
1:"models/hunter/tubes/tube1x1x1b.mdl"
2:"Model"
3:"LocalAngle"
4:"LocalPos"
5:"Skin"
6:"Frozen"
7:"PhysicsObjects"
8:"prop_physics"
9:"Class"
10:"models/props_combine/health_charger_glass"
11:"MaterialOverride"
12:"material"
13:"Mass"
14:"mass"
15:"Color"
16:"colour"
17:"EntityMods"
18:"models/props_c17/oildrum001.mdl"
19:"phoenix_storms/stripes"
20:"normal:50"
21:"value"
22:"gmod_wire_value"
23:"models/kobilica/value.mdl"
24:"CollisionGroupMod"
25:"Test Increments (max 83)"
26:"name"
27:"WireName"
28:"models/hunter/blocks/cube1x2x025.mdl"
29:"phoenix_storms/iron_rails"
30:"models/cheeze/pcb/pcb7.mdl"
31:"extended"
32:"WireDupeInfo"
33:"gmod_wire_egp"
34:"gmod_wire_expression2"
35:"TButton"
36:"ResetTest"
37:"USys"
38:"DrawGraph"
39:"Test"
40:"CurPos"
41:"NORMAL"
42:"VECTOR2"
43:"_outputs"
44:"Inertia"
45:"Progress"
46:"MinSpeed"
47:"Step"
48:"DPoints"
49:"Gravity"
50:"AirDensity"
51:"MaxSpeed"
52:"SpeedLimit"
53:"AngSpeedLimit"
54:"Torque"
55:"TickRate"
56:"WIRELINK"
57:"ARRAY"
58:"_inputs"
59:"Autodyno GUI r1-2 by Tolyzor"
60:"_name"
61:"models/expression 2/cpu_processor.mdl"
62:"@name Autodyno GUI r1-2 by Tolyzor€@inputs Progress [Torque RSD]:array MinSpeed Step MaxSpeed Inertia TickRate AirDensity Gravity SpeedLimit AngSpeedLimit DPoints€@inputs S:wirelink €@outputs Test CurPos:vector2 USys TButton ResetTest DrawGraph €@persist EgpPoints Sf DecimalAcc [PowerCol TorqueCol RSDCol Col1 Col2 Col3]:vector Tab1 Tab2 Tab3 LoadMenu LoadUnits ConBut Contrast€# graph drawing€@persist I Line Points Points2 MaxTorque MaxTorqueSpeed MaxPower MaxPowerSpeed GraphX GraphY GraphSizeX GraphSizeY Graph2Y Graph2SizeY€@persist [Pos1 Pos2 Pos3 Pos4 Pos5 Pos6 Pos7 Pos8 Pos9 Pos10 Pos11 Pos12 Pos13 Pos14 Pos15 Pos16]:vector2 MinRSD MaxRSD €# unit conversion €@persist M Ft Lb€@persist [MaxPowerS MaxTorqueS PowerLabel SpeedLabel TorqueLabel MaxPowerLabel MinSpeedLabel MaxSpeedLabel MaxTorqueLabel]:string€@persist [InertiaS GravityS SpeedLimitS AngSpeedLimitS]:string€@trigger €runOnTick(1)€if (duped()) {reset()}€if (first()) {€    S:egpClear()€    M = toUnit(£m£, 1)€    Ft = toUnit(£ft£, 1)€    Lb = toUnit(£lb£, 1)€    €    Sf = 3 # sig figures of all other numbers displayed€    DecimalAcc = 100 # rounding of rsd, air density, tickrate€    EgpPoints = 100 # the lines use index above this number. make sure its higher than the other egp objects you create€    PowerCol = vec(0, 150, 0)€    TorqueCol = vec(0, 0, 150)€    RSDCol = vec(150, 0, 0)€    USys = 1 # default units system€    €    Col1 = vec(90, 90, 170)€    Col2 = vec(170, 90, 90)€    Col3 = vec(90, 170, 90)€    €    GraphX = 45€    GraphY = 125€    GraphSizeX = 314€    GraphSizeY = 200€    €    Graph2Y = 360€    Graph2SizeY = 100€    €    LoadMenu = 1€}€if (LoadMenu) {€    €    S:egpClear()€    S:egpBox(1, vec2(256, 256), vec2(512, 512))€    if (USys == 1) {S:egpColor(1, Col1)}€    elseif (USys == 2) {S:egpColor(1, Col2)}€    else {S:egpColor(1, Col3)}€    S:egpBox(2, vec2(256, 20), vec2(512, 40))€    S:egpColor(2, vec(90, 155, 180))€    S:egpBox(3, vec2(256, 278), vec2(502, 425))€    S:egpColor(3, vec(220, 220, 220) - vec(20, 20, 20) * Contrast)€    €    S:egpBox(4, vec2(85, 50), vec2(171, 20))€    S:egpColor(4, Col1)€    S:egpBox(5, vec2(256, 50), vec2(171, 20))€    S:egpColor(5, Col2)€    S:egpBox(6, vec2(427, 50), vec2(171, 20))€    S:egpColor(6, Col3)€    €    S:egpText(7, £AUTODYNO£, vec2(12, 7))€    S:egpFont(7, £Coolvetica£, 36)€    S:egpColor(7, vec(70, 70, 70))€    S:egpText(8, £AUTODYNO£, vec2(10, 5))€    S:egpFont(8, £Coolvetica£, 36)€    S:egpText(9, £Engine Performance Test£, vec2(225, 15))€    S:egpFont(9, £Lucida Console£, 19)€    S:egpSize(9, 15)€        €    €    S:egpText(11, £Imperial Units£, vec2(35, 43))€    S:egpFont(11, £Arial£, 16)€    S:egpText(12, £S.I. Units£, vec2(220, 43))€    S:egpFont(12, £Arial£, 16)€    S:egpText(13, £Gmod Units£, vec2(385, 43))€    S:egpFont(13, £Arial£, 16)€    €    S:egpBox(14, vec2(455, 278), vec2(105, 425)) # info box€    S:egpColor(14, vec(200, 200, 200) - vec(20, 20, 20) * Contrast)€    €    S:egpBox(43, vec2(455, 465), vec2(105, 50)) # test button background€    S:egpColor(43, vec(100, 100, 100))€    €    S:egpBox(15, vec2(455, 465), vec2(105, 50)) # test button€    S:egpColor(15, vec(0, 200, 0))€    €    S:egpText(10, £v1.2                           C£ + £rea£ + £ted £ + £b£ + £y To£ + £ly£ + £z£ + £or£, vec2(15, 494))€    S:egpFont(10, £Lucida Console£, 15)€    €    S:egpText(16, £Test£, vec2(420, 445))€    S:egpFont(16, £Arial£, 40)€    LoadMenu = 0€}€€CurPos = S:egpCursor(owner())€€if (inrange(CurPos:x(), 0, 171) & inrange(CurPos:y(), 40, 60)) { # cursor is over first tab€    Tab1 = 1€    if (owner():keyUse()) {USys = 1}€} else {Tab1 = 0}€€if (inrange(CurPos:x(), 171, 341) & inrange(CurPos:y(), 40, 60)) { # cursor is over second tab€    Tab2 = 1€    if (owner():keyUse()) {USys = 2}€} else {Tab2 = 0}€€if (inrange(CurPos:x(), 341, 512) & inrange(CurPos:y(), 40, 60)) { # cursor is over third tab€    Tab3 = 1€    if (owner():keyUse()) {USys = 3}€} else {Tab3 = 0}€€if (inrange(CurPos:x(), 402, 507) & inrange(CurPos:y(), 441, 490)) { # cursor is over test button€    TButton = 1€    if (owner():keyUse()) {TButton = 2}€} else {TButton = 0}€€if (inrange(CurPos:x(), 5, 402) & inrange(CurPos:y(), 65, 490) & owner():keyUse()) { # user presses screen€   ConBut = 1€} else {ConBut = 0}€€if (changed(USys) & !first()) {soundPlay(0, 1, £buttons/blip1.wav£)}€€#if tab1 has changed€if (changed(Tab1)) {€    if (!Tab1) {S:egpColor(4, Col1)}€    elseif (Tab1 == 1) {S:egpColor(4, Col1 + vec(40, 40, 40))}€}€€#if tab2 has changed€if (changed(Tab2)) {€    if (!Tab2) {S:egpColor(5, Col2)}€    elseif (Tab2 == 1) {S:egpColor(5, Col2 + vec(40, 40, 40))}€}€€#if tab3 has changed€if (changed(Tab3)) {€    if (!Tab3) {S:egpColor(6, Col3)}€    elseif (Tab3 == 1) {S:egpColor(6, Col3 + vec(40, 40, 40))}€}€€if (changed(TButton)) {€    if (!TButton) {S:egpColor(15, vec(0, 200, 0))}€    elseif (TButton == 1) {S:egpColor(15, vec(40, 240, 40))}€    elseif (TButton == 2) {€        S:egpClear()€        LoadMenu = 1€        soundPlay(0, 1, £buttons/button1.wav£)€        ResetTest = 1€        Test = 0€    }€}€€if (changed(ConBut) & ConBut) {€    Contrast = !Contrast€    soundPlay(0, 1, £buttons/button18.wav£)€    if (Contrast) {€        S:egpColor(3, vec(200, 200, 200))€        S:egpColor(14, vec(180, 180, 180))€        } else {€        S:egpColor(3, vec(220, 220, 220))€        S:egpColor(14, vec(200, 200, 200))€    }€}€€if (Test & changed(Progress)) {€    S:egpSize(15, vec2(floor(Progress * 105), 50)) €    S:egpPos(15, vec2(floor(402.5 + Progress * 52.5), 465))€}€€€if (TButton == 2 & !ResetTest) {Test = 1}€if (TButton == 2) {ResetTest = 0}€€## results display ##€if (Progress == 1 & (~Progress | first())) {€    Test = 0€    ResetTest = 1€    DrawGraph = 1€    LoadMenu = 1€    S:egpClear()€    exit()€}€€if (DrawGraph) {€    if (DrawGraph == 1) {€        I = Line = MaxPower = 0€        Points = Torque:count() €        MaxTorque = Torque:max()€        MaxTorqueSpeed = MaxSpeed - ((Torque:maxIndex() - 1) * Step)€        #S:egpClear()€        #S:egpLoadFrame(£frame£)€        DrawGraph = 2€    }€    while(DrawGraph < 4 & perf()) {€        I++€        if (I > Points) {€            DrawGraph++€            Line = 1€            I = 1€        }€        Sx1 = GraphX + GraphSizeX * clamp((Points - I) / (Points - 1), 0, 1)€        Sx2 = GraphX + GraphSizeX * clamp((Points - (I + 1)) / (Points - 1), 0, 1)€        if (!Line) {€            Speed = (MaxSpeed - (I - 1) * Step)€            Power = Torque[I, number] * Speed€            if (MaxPower < Power) {€                MaxPower = Power€                MaxPowerSpeed = Speed€            }€            Sy1 = GraphY + GraphSizeY * (1 - Torque[I, number] / MaxTorque)€            Sy2 = GraphY + GraphSizeY * (1 - Torque[I + 1, number] / MaxTorque)€            S:egpLine(EgpPoints + I, vec2(Sx1, Sy1), vec2(Sx2, Sy2))€            S:egpColor(EgpPoints + I, TorqueCol)€            #S:egpSize(EgpPoints + I, 2)€        }  else {€            Speed1 = (MaxSpeed - ((I - 1) * Step))€            Speed2 = (MaxSpeed - (I * Step))€            Sy1 = GraphY + GraphSizeY * (1 - Torque[I, number] * Speed1 / MaxPower)€            Sy2 = GraphY + GraphSizeY * (1 - Torque[I + 1, number] * Speed2 / MaxPower)€            S:egpLine(EgpPoints + Points + I, vec2(Sx1, Sy1), vec2(Sx2, Sy2))€            S:egpColor(EgpPoints + Points + I, PowerCol)€            #S:egpSize(EgpPoints + Points + I, 2)€        }€    }€    if (DrawGraph == 4) {€        I = Line = 0€        Points2 = RSD:count() €        MaxRSD = RSD:max()€        MinRSD = RSD:min()€        #MaxRSDSpeed = MaxSpeed - ((RSD:maxIndex() - 1) * Step)€        DrawGraph = 5€    }€    while(DrawGraph == 5 & perf()) {€        I++€        Sx1 = GraphX + GraphSizeX * clamp((Points - I) / (Points2 - 1), 0, 1)€        Sx2 = GraphX + GraphSizeX * clamp((Points - (I + 1)) / (Points2 - 1), 0, 1)€        Sy1 = Graph2Y + Graph2SizeY * clamp((1 - (RSD[I, number] - MinRSD) / (MaxRSD - MinRSD)), 0, 1)€        Sy2 = Graph2Y + Graph2SizeY * clamp((1 - (RSD[I + 1, number] - MinRSD) / (MaxRSD - MinRSD)), 0, 1)€        S:egpLine(EgpPoints + (Points * 2) + I, vec2(Sx1, Sy1), vec2(Sx2, Sy2))€        S:egpColor(EgpPoints + (Points * 2) + I, RSDCol)€        if (I > Points2) {€            DrawGraph = 6€        }€    }€    €    if (DrawGraph == 6) {€        €        Pos1 = vec2(GraphX, GraphY + GraphSizeY + 10)€        Pos5 = vec2(GraphX, GraphY)€        S:egpLine(17, Pos5, Pos1) # power axis€        S:egpColor(17, vec(0, 0, 0))€        S:egpSize(17, 2)€        €        Pos2 = vec2(GraphX - 10, GraphY + GraphSizeY)€        Pos3 = vec2(GraphX + GraphSizeX + 10, GraphY + GraphSizeY)€        S:egpLine(18, Pos2, Pos3) # Speed axis€        S:egpColor(18, vec(0, 0, 0))€        S:egpSize(18, 2)€        €        Pos4 = vec2(GraphX + GraphSizeX, GraphY + GraphSizeY + 10)€        Pos6 = vec2(GraphX + GraphSizeX, GraphY)€        S:egpLine(19, Pos6, Pos4) # torque axis€        S:egpColor(19, vec(0, 0, 0))€        S:egpSize(19, 2)€        €        S:egpText(20, £0£, Pos2 + vec2(5, 1)) # power axis 0€        S:egpFont(20, £Arial£, 11)€        S:egpColor(20, PowerCol)€        S:egpAlign(20, 1)€        €        S:egpText(21, £0£, Pos3 + vec2(-4, 1)) # torque axis 0€        S:egpFont(21, £Arial£, 11)€        S:egpColor(21, TorqueCol)€        S:egpAlign(21, 1)€        €        S:egpLine(22, Pos5, Pos5 + vec2(-10, 0)) # power axis max marker€        S:egpColor(22, vec(0, 0, 0))€        S:egpSize(22, 2)€        €        S:egpLine(23, Pos6, Pos6 + vec2(10, 0)) # torque axis max marker€        S:egpColor(23, vec(0, 0, 0))€        S:egpSize(23, 2)€        €        # RSD graph€        Pos10 = vec2(GraphX, Graph2Y + Graph2SizeY + 10)€        Pos11 = vec2(GraphX, Graph2Y)€        S:egpLine(33, Pos11, Pos10) # RSD axis€        S:egpColor(33, vec(0, 0, 0))€        S:egpSize(33, 2)€        €        Pos12 = vec2(GraphX - 10, Graph2Y + Graph2SizeY)€        Pos13 = vec2(GraphX + GraphSizeX, Graph2Y + Graph2SizeY)€        S:egpLine(34, Pos12, Pos13) # Speed axis€        S:egpColor(34, vec(0, 0, 0))€        S:egpSize(34, 2)€        €        S:egpLine(35, Pos11, Pos11 + vec2(-10, 0)) # RSD axis max marker€        S:egpColor(35, vec(0, 0, 0))€        S:egpSize(35, 2)€        €        S:egpLine(36, Pos13, Pos13 + vec2(0, 10)) # speed max marker€        S:egpColor(36, vec(0, 0, 0))€        S:egpSize(36, 2)€        €        # RSD axis title€        Pos15 = vec2(GraphX, Graph2Y + Graph2SizeY / 2)€        S:egpTextLayout(37, £RSD \\n(%)£, Pos15 + vec2(-53, 0), vec2(50, 50))€        S:egpFont(37, £Arial£, 11)€        S:egpColor(37, RSDCol)€        S:egpAlign(37, 2)€        €        # RSD axis min label€        MinRSDLabel = (round(DecimalAcc * MinRSD) / DecimalAcc):toString()€        S:egpText(38, MinRSDLabel, Pos12 + vec2(7, 1)) €        S:egpFont(38, £Arial£, 11)€        S:egpColor(38, RSDCol)€        S:egpAlign(38, 2)€        €        # RSD axis max label€        MaxRSDLabel = (round(DecimalAcc * MaxRSD) / DecimalAcc):toString()€        S:egpText(39, MaxRSDLabel, Pos11 + vec2(-3, 1))€        S:egpFont(39, £Arial£, 11)€        S:egpColor(39, RSDCol)€        S:egpAlign(39, 2)€        €        # Test Conditions info box title€        S:egpTextLayout(45, £Test Conditions£, vec2(405, 150), vec2(100, 50))€        S:egpFont(45, £Arial£, 15)€        S:egpColor(45, vec(0, 0, 0))€        S:egpAlign(45, 1)€        €        AirDensityS = (round(DecimalAcc * AirDensity) / DecimalAcc):toString() # cant assign it units...€        S:egpTextLayout(47, £Air density: \\n£ + AirDensityS, vec2(420, 220), vec2(80, 50))€        S:egpFont(47, £Arial£, 13)€        S:egpColor(47, vec(0, 0, 0))€        S:egpAlign(47, 1)€        €        TickRateS = (round(DecimalAcc * TickRate) / DecimalAcc):toString()€        S:egpTextLayout(48, £Tick rate: \\n£ + TickRateS + £ ticks/s£, vec2(420, 260), vec2(80, 50))€        S:egpFont(48, £Arial£, 13)€        S:egpColor(48, vec(0, 0, 0))€        S:egpAlign(48, 1)€        €        TestIncrementsS = (Torque:count()):toString()€        InputIncrementsS = floor(clamp(DPoints, 3, 83)):toString()€        S:egpTextLayout(51, £Test increments: \\n£ + TestIncrementsS + £/£ + InputIncrementsS, vec2(410, 380), vec2(100, 50))€        S:egpFont(51, £Arial£, 13)€        S:egpColor(51, vec(0, 0, 0))€        S:egpAlign(51, 1)€        €        DrawGraph = 0€        LoadUnits = 1€        }         €}€€# Unit system ###########################################€€if ((changed(USys) | LoadUnits) & Progress == 1) {€    if (USys == 1) {€        S:egpColor(1, Col1)€        €        Val1 = MaxPower * M^2 * 0.00134102209 # horsepower€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€        €        Val2 = toDeg(MaxPowerSpeed) / 6 # rotations per minute€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val2S = Val2:toString()€                €        MaxPowerS = £Max power: £ + Val1S + £ hp @ £ + Val2S + £ rpm£€        MaxPowerLabel = Val1S€        €        Val1 = MaxTorque * M^2 * 0.737562149 # lbf.ft€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€                        €        Val2 = toDeg(MaxTorqueSpeed) / 6 # rotations per minute€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val2S = Val2:toString()€        if (MaxTorqueSpeed <= 0.01) {Val2S = (0):toString()} # prevent £e-19 bug£€        €        MaxTorqueS = £Max torque: £ + Val1S + £ ft.lbf @ £ + Val2S + £ rpm£€        MaxTorqueLabel = Val1S€        €        PowerLabel = £Power \\n (hp)£€        SpeedLabel = £Speed (rpm)£€        TorqueLabel = £Torque \\n (ft.lbf)£€        €        Val1 = toDeg(MinSpeed) / 6 # rotations per minute€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€        MinSpeedLabel = Val1S€        if (MinSpeed <= 0.01) {MinSpeedLabel = (0):toString()} # prevent £e-19 bug£€        €        Val1 = toDeg(MaxSpeed) / 6 # rotations per minute€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€                €        MaxSpeedLabel = Val1S€        €        Val1 = Inertia * Ft^2 * Lb€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€        InertiaS = £Crankshaft MoI: \\n£ + Val1S + £ lb.ft^2£€        €        Val1 = abs(Gravity * Ft)€        Order = floor(log10(Val1))€        Val1 = sign(Gravity * M) * (round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf)€        Val1S = Val1:toString()€        GravityS = £Gravity: \\n£ + Val1S + £ ft/s^2£€        €        Val1 = SpeedLimit * Ft€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€        SpeedLimitS = £Speed limit: \\n£ + Val1S + £ ft/s£€        €        Val1 = toDeg(AngSpeedLimit) / 6€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) * 10^Order / 10^Sf€        Val1S = Val1:toString()€        AngSpeedLimitS = £Ang speed limit: \\n£ + Val1S + £ rpm£€        €    }€    elseif (USys == 2) {€        S:egpColor(1, Col2)€        €        Val1 = MaxPower * M^2 # watts€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        €        Val2 = MaxPowerSpeed # radians per second€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) / 10^Sf€        Val2S = Val2:toString() + £e£ + Order:toString()€        €        MaxPowerS = £Max power: £ + Val1S + £ watts @ £ + Val2S + £ rad/s£€        MaxPowerLabel = Val1S€        €        Val1 = MaxTorque * M^2 # newton meters€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        €        Val2 = MaxTorqueSpeed # radians per second€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) / 10^Sf€        Val2S = Val2:toString() + £e£ + Order:toString()€        if (MaxTorqueSpeed <= 0.01) {Val2S = (0):toString()} # prevent £e-19 bug£€        €        MaxTorqueS = £Max torque: £ + Val1S + £ n.m @ £ + Val2S + £ rad/s£€        MaxTorqueLabel = Val1S€        €        PowerLabel = £Power \\n (watts)£€        SpeedLabel = £Speed (rad/s)£€        TorqueLabel = £Torque \\n (n.m)£€        €        Val1 = MinSpeed€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        MinSpeedLabel = Val1S # rad/s€        if (MinSpeed <= 0.01) {MinSpeedLabel = (0):toString()} # prevent £e-19 bug£€        €        Val1 = MaxSpeed€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        MaxSpeedLabel = Val1S # rad/s€        €        Val1 = Inertia * M^2€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        InertiaS = £Crankshaft MoI: \\n£ + Val1S + £ kg.m^2£€        €        Val1 = abs(Gravity * M)€        Order = floor(log10(Val1))€        Val1 = sign(Gravity * M) * (round(Val1 * 10^(Sf - Order)) / 10^Sf)€        Val1S = Val1:toString() + £e£ + Order:toString()€        GravityS = £Gravity: \\n£ + Val1S + £ m/s^2£€        €        Val1 = SpeedLimit * M€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        SpeedLimitS = £Speed limit: \\n£ + Val1S + £ m/s£€        €        Val1 = AngSpeedLimit€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        AngSpeedLimitS = £Ang speed limit: \\n£ + Val1S + £ rad/s£€        €    }€    elseif (USys == 3) {€        S:egpColor(1, Col3)€        €        Val1 = MaxPower # gpu€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        €        Val2 = MaxPowerSpeed # radians per second€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) / 10^Sf€        Val2S = Val2:toString() + £e£ + Order:toString()€        €        MaxPowerS = £Max power: £ + Val1S + £ gpu @ £ + Val2S + £ rad/s£€        MaxPowerLabel = Val1S€        €        Val1 = MaxTorque # Gmod torque units€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        €        Val2 = MaxTorqueSpeed # radians per second€        Order = floor(log10(Val2))€        Val2 = round(Val2 * 10^(Sf - Order)) / 10^Sf€        Val2S = Val2:toString() + £e£ + Order:toString()€        if (MaxTorqueSpeed <= 0.01) {Val2S = (0):toString()} # prevent £e-19 bug£€        €        MaxTorqueS = £Max torque: £ + Val1S + £ gfu.glu @ £ + Val2S + £ rad/s£€        MaxTorqueLabel = Val1S€                €        PowerLabel = £Power \\n (gpu)£€        SpeedLabel = £Speed (rad/s)£€        TorqueLabel = £Torque \\n (gfu.glu)£€        €        Val1 = MinSpeed€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        MinSpeedLabel = Val1S # rad/s€        if (MinSpeed <= 0.01) {MinSpeedLabel = (0):toString()} # prevent £e-19 bug£€        €        Val1 = MaxSpeed€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        MaxSpeedLabel = Val1S # rad/s€        €        Val1 = Inertia €        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        InertiaS = £Crankshaft MoI: \\n£ + Val1S + £ kg.glu^2£€        €        Val1 = abs(Gravity)€        Order = floor(log10(Val1))€        Val1 = sign(Gravity) * (round(Val1 * 10^(Sf - Order)) / 10^Sf)€        Val1S = Val1:toString() + £e£ + Order:toString()€        GravityS = £Gravity: \\n£ + Val1S + £ glu/s^2£€        €        Val1 = SpeedLimit €        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        SpeedLimitS = £Speed limit: \\n£ + Val1S + £ glu/s£€        €        Val1 = AngSpeedLimit€        Order = floor(log10(Val1))€        Val1 = round(Val1 * 10^(Sf - Order)) / 10^Sf€        Val1S = Val1:toString() + £e£ + Order:toString()€        AngSpeedLimitS = £Ang speed limit: \\n£ + Val1S + £ rad/s£€                €    }€    # Max power string    €    S:egpText(24, MaxPowerS, vec2(20, 70))€    S:egpFont(24, £Arial£, 18)€    S:egpColor(24, PowerCol)€    €    # Max torque string€    S:egpText(25, MaxTorqueS, vec2(20, 95))€    S:egpFont(25, £Arial£, 18)€    S:egpColor(25, TorqueCol)€    €    # Power axis title€    Pos8 = vec2(GraphX, GraphY + GraphSizeY / 2)€    S:egpTextLayout(26, PowerLabel, Pos8 + vec2(-53, 0), vec2(50, 50))€    S:egpFont(26, £Arial£, 11)€    S:egpColor(26, PowerCol)€    S:egpAlign(26, 2)€    €    €    # Speed axis title€    Pos7 = vec2(GraphX + GraphSizeX / 2, GraphY + GraphSizeY)€    S:egpTextLayout(27, SpeedLabel, Pos7, vec2(50, 50))€    S:egpFont(27, £Arial£, 11)€    S:egpColor(27, vec(0, 0, 0))€    €    # Torque axis label€    Pos9 = vec2(GraphX + GraphSizeX, GraphY + GraphSizeY / 2)€    S:egpTextLayout(28, TorqueLabel, Pos9 + vec2(2, 0), vec2(50, 50))€    S:egpFont(28, £Arial£, 11)€    S:egpColor(28, TorqueCol)€    €    # power axis max label€    S:egpText(29, MaxPowerLabel, Pos5 + vec2(-3, 1))€    S:egpFont(29, £Arial£, 11)€    S:egpColor(29, PowerCol)€    S:egpAlign(29, 2)€    €    # speed axis min label€    S:egpText(30, MinSpeedLabel, Pos1)€    S:egpFont(30, £Arial£, 11)€    S:egpColor(30, vec(0, 0, 0))€    S:egpAlign(30, 1)€    €    # speed axis max label€    S:egpText(31, MaxSpeedLabel, Pos4)€    S:egpFont(31, £Arial£, 11)€    S:egpColor(31, vec(0, 0, 0))€    S:egpAlign(31, 1)€    €    # torque axis max label€    S:egpText(32, MaxTorqueLabel, Pos6 + vec2(3, 1))€    S:egpFont(32, £Arial£, 11)€    S:egpColor(32, TorqueCol)€    €    # RSD Speed axis title€    Pos16 = vec2(GraphX + GraphSizeX / 2, Graph2Y + Graph2SizeY)€    S:egpTextLayout(40, SpeedLabel, Pos16, vec2(50, 50))€    S:egpFont(40, £Arial£, 11)€    S:egpColor(40, vec(0, 0, 0))€    €    # RSD speed axis min label€    S:egpText(41, MinSpeedLabel, Pos10)€    S:egpFont(41, £Arial£, 11)€    S:egpColor(41, vec(0, 0, 0))€    S:egpAlign(41, 1)€    €    # RSD speed axis max label€    S:egpText(42, MaxSpeedLabel, Pos13 + vec2(0, 10))€    S:egpFont(42, £Arial£, 11)€    S:egpColor(42, vec(0, 0, 0))€    S:egpAlign(42, 1)€    €    # Info box info ##########€        €    S:egpTextLayout(44, InertiaS, vec2(410, 80), vec2(100, 50))€    S:egpFont(44, £Arial£, 13)€    S:egpColor(44, vec(0, 0, 0))€    S:egpAlign(44, 1)€    €    S:egpTextLayout(46, GravityS, vec2(420, 180), vec2(80, 50))€    S:egpFont(46, £Arial£, 13)€    S:egpColor(46, vec(0, 0, 0))€    S:egpAlign(46, 1)€    €    S:egpTextLayout(49, SpeedLimitS, vec2(420, 300), vec2(80, 50))€    S:egpFont(49, £Arial£, 13)€    S:egpColor(49, vec(0, 0, 0))€    S:egpAlign(49, 1)€    €    S:egpTextLayout(50, AngSpeedLimitS, vec2(410, 340), vec2(100, 50))€    S:egpFont(50, £Arial£, 13)€    S:egpColor(50, vec(0, 0, 0))€    S:egpAlign(50, 1)€    €    LoadUnits = 0€} elseif (changed(USys)) {€    if (USys == 1) {S:egpColor(1, Col1)}€    elseif (USys == 2) {S:egpColor(1, Col2)}€    else {S:egpColor(1, Col3)}€}€€# By Tolyzor€# Please do not copy or modify this code, if you would like to use an aspect of it, please contact me at wiremod.com€#€# Contact for support at wiremod.com€€€        €        €€€€€€"
63:"_original"
64:"Path"
65:"SrcId"
66:"SrcPos"
67:"arrowire/arrowire"
68:"Material"
69:"StartPos"
70:"Width"
71:"link"
72:"cable/cable2"
73:"SpeedStep"
74:"Value1"
75:"RSDArray"
76:"MaxAngSpeed"
77:"TorqueArray"
78:"Wires"
79:"MinRSD"
80:"MaxPowerS"
81:"Pos4"
82:"SpeedLabel"
83:"PowerCol"
84:"TickRateS"
85:"MaxRSDLabel"
86:"RSDCol"
87:"EgpPoints"
88:"Pos2"
89:"LoadMenu"
90:"MaxTorqueSpeed"
91:"Val2S"
92:"MinRSDLabel"
93:"$RSD"
94:"SpeedLimitS"
95:"MaxPower"
96:"InputIncrementsS"
97:"Speed"
98:"Points"
99:"MaxSpeedLabel"
100:"Contrast"
101:"TestIncrementsS"
102:"TorqueLabel"
103:"MaxPowerLabel"
104:"Pos10"
105:"Pos3"
106:"LoadUnits"
107:"TorqueCol"
108:"Pos1"
109:"Pos13"
110:"GravityS"
111:"Val1S"
112:"Speed1"
113:"GraphY"
114:"Col3"
115:"Tab2"
116:"Pos15"
117:"Pos7"
118:"Graph2SizeY"
119:"Pos6"
120:"Pos11"
121:"Pos14"
122:"Tab1"
123:"GraphSizeX"
124:"Col2"
125:"Power"
126:"Points2"
127:"Val2"
128:"AngSpeedLimitS"
129:"GraphSizeY"
130:"Pos12"
131:"GraphX"
132:"DecimalAcc"
133:"Pos9"
134:"Graph2Y"
135:"Order"
136:"MaxTorqueLabel"
137:"Pos5"
138:"PowerLabel"
139:"Line"
140:"Pos16"
141:"MaxPowerSpeed"
142:"MaxTorque"
143:"Col1"
144:"ConBut"
145:"InertiaS"
146:"AirDensityS"
147:"Tab3"
148:"MinSpeedLabel"
149:"MaxTorqueS"
150:"Val1"
151:"$Torque"
152:"MaxRSD"
153:"Pos8"
154:"Speed2"
155:"_vars"
156:"SumError"
157:"TransSpeed"
158:"AvgAcc"
159:"SpeedArray"
160:"Error"
161:"OpSpeed"
162:"Timer1"
163:"AvgTorqueOut"
164:"AvgSpeed"
165:"TorqueOutArray"
166:"Timer5"
167:"GainLevel"
168:"AbsMaxSpeed"
169:"Phase"
170:"MaxLMinSpeed"
171:"Timer4"
172:"OffAxisAngSpeed"
173:"Timer3"
174:"Timer2"
175:"Timer6"
176:"Rotor"
177:"ENTITY"
178:"Autodyno PID control r1-2 by Tolyzor"
179:"@name Autodyno PID control r1-2 by Tolyzor€@inputs Test DPoints Rotor:entity T AirDensity SpeedLimit€@outputs GainLevel [TorqueArray RSDArray]:array SpeedStep MinSpeed MaxSpeed Inertia Progress €# test sequence€@outputs Phase Timer1 Timer2 Timer3 Timer4 Timer5 Timer6 OffAxisAngSpeed TransSpeed€@persist Loop1 Loop2 Loop3 ErrorArray:array PrintErrors I€#testing constants€@outputs AbsMaxSpeed MaxLMinSpeed OpSpeed AvgAcc AvgSpeed AvgTorqueOut [SpeedArray TorqueOutArray]:array €@persist Speed Rotations SumAcc SumSpeed RotorMass SpeedRange TorqueClamp€@persist PIDRSD SumDev IStartIndex IEndIndex IStartSpeed IEndSpeed SumITorque€# pid control€@outputs Kp Ki Kd Dir Error SumError €@trigger Test€runOnTick(Test)€€if (~Test & Test) {reset()}€€DPoints = floor(clamp(DPoints - 1, 3, 84)) # # clamped to 83 because any more will overload egp element limit of 300 (assuming 51 elements already on screen)€Speed = toRad(Rotor:angVelVector():z())€€# Cancel out drag from the rotor€Drag = 59.75 * AirDensity * Speed^2 * Dir€Rotor:applyTorque(vec(0, 0, Drag) / T)€€# Rotor axis strength adjustment€OffAxisAngSpeed = toRad(Rotor:angVelVector():setZ(0):length())€TransSpeed = Rotor:vel():length()€Timer3++€€# dont increase mass if the test is trying to find max speed €if (Timer3 > 2 * T & (OffAxisAngSpeed > 2 | TransSpeed > 2) & !(OpSpeed > SpeedLimit * 0.9 & AvgTorqueOut < 0)) {€    if (Rotor:mass() < 5e4) {€        ErrorString = £Warning: rotor axis overload at increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s], increasing rotor mass£€        hint(ErrorString, 7)€        ErrorArray:pushString(ErrorString)€        RotorMass += 4950 # 10 increments up to 5e4 kg€        Rotor:setMass(RotorMass) €    } elseif (OffAxisAngSpeed > 3.5 | TransSpeed > 3.5) {€        ErrorString = £Error: Rotor axis terminaly overloaded at increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s], terminating test£€        hint(ErrorString, 7)€        ErrorArray:pushString(ErrorString)€        owner():soundPlay(0, 1, £buttons/button10.wav£)€        Phase = 7€        Progress = 1€        exit()€    } else {€    ErrorString = £Warning: rotor axis overload at increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s], rotor mass increase not possible£€    hint(ErrorString, 7)€    ErrorArray:pushString(ErrorString)€    }€    Timer3 = 0€}€€if (!Phase) {## Set constants€    Rotations = 3 # engine output is measured over 8 rotations€    RotorMass = 50 # start off with rotor at 50€    Rotor:setMass(RotorMass) €    Dir = sign(Speed)€    PIDRSD = 0 # inherant PID rsd€    MaxLMinSpeed = 9e9 # temp value to find min€    Phase = 1    €    €} elseif (Phase == 1) {## find absolute max speed (no higher speed for past 2 seconds)€    Timer1++€    Timer4++€    Timer5++€    if (Timer5 > T * 40) {€        ErrorString = £Error: Failed to find abs max speed£€        hint(ErrorString, 7)€        ErrorArray:pushString(ErrorString)€        owner():soundPlay(0, 1, £buttons/button10.wav£)€        AbsMaxSpeed = OpSpeed = clamp(ceil(abs(AvgSpeed) * 1000) / 1000, 0, SpeedLimit) # testing will start at this speed€        Phase = 2€        Timer1 = Timer5 = 0€        Progress = 0.02€    }€    SumSpeed += Speed * Dir€    Time = clamp(ceil((Rotations * 2 * pi()) / (abs(Speed) / T)), 0, 2 * T)€    if (Timer4 >= Time) {€        AvgSpeed = SumSpeed / Time€        SumSpeed = Timer4 = 0€    }€    €    if (AbsMaxSpeed < ceil(abs(AvgSpeed) * 1000) / 1000 & AbsMaxSpeed < SpeedLimit) {€        AbsMaxSpeed = OpSpeed = clamp(ceil(abs(AvgSpeed) * 1000) / 1000, 0, SpeedLimit) # testing will start at this speed€        SpeedStep = clamp(AbsMaxSpeed / (DPoints * 5), 0, 0.7) # increment starts off 5x smaller than normal to find maxSpeed€        SpeedRange = 0.5 # allowable range starts off at 0.5€        Timer1 = 0€    }€    if (Timer1 > 8.5 * T) {€        Phase = 2€        Timer1 = Timer5 = 0€        Progress = 0.02€    }€    €    €    €} elseif (Phase == 2) {## find local minimum max speed test bracket (no lower speed for past 2 seconds)€    Timer1++€    Timer5++€    if (Timer5 > T * 30) {€        ErrorString = £Error: Failed to find abs max min speed£€        hint(ErrorString, 7)€        ErrorArray:pushString(ErrorString)€        owner():soundPlay(0, 1, £buttons/button10.wav£)€        MaxLMinSpeed = floor(abs(Speed) * 1000) / 1000€        Phase = 3€        Timer1 = Timer5 = 0€        Progress = 0.04€    }€    if (MaxLMinSpeed > floor(abs(Speed) * 1000) / 1000) {€        MaxLMinSpeed = (floor(abs(Speed) * 1000) / 1000) - 3 # maxlmin is 3 rad/s slower than real to make sure torque is found€        Timer1 = 0€    }€    if (Timer1 > 2 * T) {€        Phase = 3€        Timer1 = Timer5 = 0€        Progress = 0.04€    }€    €    €} elseif (Phase == 3) {# PID gain scheduling - calculate required constants€    Timer6++€    Timer5++€    if (Timer6 > T * 5) { # apply a set torque for 5 seconds and watch for speed change€        GainLevel++€        Timer6 = 0€    }€    if (Timer5 > T * 30) {€        ErrorString = £Error: Dynamometer over-torqued, terminating test£€        hint(ErrorString, 7)€        ErrorArray:pushString(ErrorString)€        owner():soundPlay(0, 1, £buttons/button10.wav£)€        Phase = 8€        Progress = 1€        PrintErrors = 1€        I = 1€        exit()€    }€    if (!GainLevel) {€        Torque = -Dir * 1e4€        Rotor:setMass(50)€    }€    elseif (GainLevel == 1) {€        Torque = -Dir * 5e7€        Rotor:setMass(350)€    }€    elseif (GainLevel == 2) {€        Torque = -Dir * 5e9€        Rotor:setMass(5e3)€    }€    else {€        Torque = -Dir * 1e11€        Rotor:setMass(5e4)€    }€    Rotor:applyTorque(vec(0, 0, Torque) / T)€    €    if (Speed * Dir < 0 | GainLevel > 3) {# Set PID controller constants and torque clamp €            €        if (!GainLevel) {€            Kp = 1e1€            Ki = 1e1€            Kd = 1e3€            TorqueClamp = 2e4€            Rotor:setMass(50)€        }€        elseif (GainLevel == 1) {€            Kp = 1e6€            Ki = 5e5€            Kd = 5e5€            TorqueClamp = 2e8€            Rotor:setMass(1e3)€        }€        elseif (GainLevel == 2) {€            Kp = 5e7€            Ki = 9e6€            Kd = 5e5€            TorqueClamp = 1e10€            Rotor:setMass(5e3)€        }€        else {€            Kp = 5e8€            Ki = 9e7€            Kd = 5e5€            TorqueClamp = 1.3e11€            Rotor:setMass(5e4)€        }€        Phase = 4€    }    €€} elseif (Phase == 4 | Phase == 5) {### Begin testing and PID control takeover of engine€    # PID CONTROLLER (augmented with rotor drag & inertia canceling code)€    Error = (OpSpeed * Dir - Speed)€    if (inrange(SumError * Ki, -TorqueClamp - Error * Ki, TorqueClamp - Error * Ki)) { # prevent integral wind up€        SumError += Error€    }€    P = Kp * Error€    I = Ki * SumError€    D = Kd * $Error€    Momentum = Rotor:inertia():z() * 1550.1 * Error * T€    €    Torque = clamp(Momentum + P + I + D, -TorqueClamp, TorqueClamp) €€    Rotor:applyTorque(vec(0, 0, Torque) / T)€€    TorqueOut = P + I + D # the only controller components which resist the engine being tested€€    # Output analysis€    €    Timer2++ # time how long each increment takes€    # ticks to do x rotations€    Time = clamp(ceil((Rotations * 2 * pi()) / (abs(Speed) / T)), 0, 7 * T)€    €        €    if (Timer2 > T * 2) { # give pid response 2 seconds to work and stabalise€        # average engine output€        Timer1++€        SumAcc += $Speed * T * Dir€        SumSpeed += Speed * Dir€        TorqueOutArray:pushNumber(TorqueOut * Dir * -1)€    }€        if (Timer1 >= Time) { # if rotor has just completed x rotations, calculate data€            AvgAcc = SumAcc / Time€            AvgSpeed = SumSpeed / Time€            AvgTorqueOut = TorqueOutArray:average()€                        €            for (Loop1 = 1, Time) { # calculate relative standard deviation€                SumDev += (AvgTorqueOut - TorqueOutArray[Loop1, number])^2€            }€            TorqueOutArray = array()€            RSD = sqrt(SumDev / Time) * 100 / abs(AvgTorqueOut) # relative standard deviation percentage€            SumSpeed = SumAcc = SumDev = Timer1 = 0€        €        if (Phase == 4) {## start torque test€            €            if (Timer2 > 5 * T & OpSpeed > SpeedLimit * 0.9 & AvgTorqueOut < 0) { # if opSpeed is greater than 90% of speed limit€                ErrorString = £Warning: increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s] failed due to speed limit£€                hint(ErrorString, 7)€                ErrorArray:pushString(ErrorString)€                if (TorqueArray:count() > 1) { €                    TorqueArray:pushNumber(0)€                    RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                    OpSpeed -= SpeedStep€                } else {OpSpeed -= SpeedStep}€            } elseif (Timer2 > 15 * T) { # if increment takes longer than x seconds€                if (AvgTorqueOut > 0 & AvgSpeed > OpSpeed) {€                    if (GainLevel < 3) {€                        GainLevel++€                        if (GainLevel == 1) {€                            Kp = 1e6€                            Ki = 5e5€                            Kd = 5e5€                            TorqueClamp = 2e8€                            Rotor:setMass(1e3)€                        }€                        elseif (GainLevel == 2) {€                            Kp = 5e7€                            Ki = 9e6€                            Kd = 5e5€                            TorqueClamp = 1e10€                            Rotor:setMass(5e3)€                        }€                        else {€                            Kp = 5e8€                            Ki = 9e7€                            Kd = 5e5€                            TorqueClamp = 1.3e11€                            Rotor:setMass(5e4)€                        }€                        ErrorString = £Warning: Dynamometer over-torqued at increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s], increasing PID constants£€                        hint(ErrorString, 7)€                        ErrorArray:pushString(ErrorString)€                        Timer1 = Timer2 = 0€                    } else {€                        ErrorString = £Error: Dynamometer over-torqued at increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s], terminating test£€                        hint(ErrorString, 7)€                        ErrorArray:pushString(ErrorString)€                        owner():soundPlay(0, 1, £buttons/button10.wav£)€                        Phase = 8€                        Progress = 1€                        PrintErrors = 1€                        I = 1€                        exit()€                    }€                    €                } elseif (OpSpeed > MaxLMinSpeed) { # if opSpeed is greater than min oscilation of max speed€                    ErrorString = £Error: increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s] failed due to rough engine max speed£€                    hint(ErrorString, 7)€                    ErrorArray:pushString(ErrorString)€                    owner():soundPlay(0, 1, £buttons/button10.wav£)€                    if (TorqueArray:count() > 1) { €                        TorqueArray:pushNumber(0)€                        RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                        OpSpeed -= SpeedStep€                    } else {OpSpeed -= SpeedStep}€                } elseif ((OpSpeed < MaxLMinSpeed & AvgTorqueOut < 0) | OpSpeed <= 0) {€                    ErrorString = £Error: increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s] failed at min speed£€                    hint(ErrorString, 7)€                    ErrorArray:pushString(ErrorString)€                    owner():soundPlay(0, 1, £buttons/button10.wav£)€                    MinSpeed = clamp(OpSpeed, 0, 9e15) €                    Timer1 = 0€                    Phase = 5€                    TorqueArray:pushNumber(0) # torque out is none€                    RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                } elseif (inrange(AvgSpeed, OpSpeed - SpeedStep / 2, OpSpeed + SpeedStep / 2)) {€                    ErrorString = £Error: increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s] outside acceleration bounds£€                    hint(ErrorString, 7)€                    ErrorArray:pushString(ErrorString)€                    owner():soundPlay(0, 1, £buttons/button10.wav£)€                    if (TorqueArray:count() > 1) { €                        TorqueArray:pushNumber(0)€                        RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                        OpSpeed -= SpeedStep€                    } else {OpSpeed -= SpeedStep}€                } else {€                    ErrorString = £Error: increment [£ + (round(OpSpeed * 1e3) / 1e3):toString() + £ rad/s] failed£€                    hint(ErrorString, 7)€                    ErrorArray:pushString(ErrorString)€                    owner():soundPlay(0, 1, £buttons/button10.wav£)€                    if (TorqueArray:count() > 1) { # unkown failure reason€                        TorqueArray:pushNumber(0)€                        RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                        OpSpeed -= SpeedStep€                    } else {OpSpeed -= SpeedStep}€                }€            }€            €            if (abs(AvgAcc) < 0.25 & inrange(AvgSpeed, OpSpeed - SpeedRange, OpSpeed + SpeedRange)) {€                if (AvgTorqueOut > 0) {€                    if (!MaxSpeed) {€                        MaxSpeed = OpSpeed€                        SpeedStep = MaxSpeed / DPoints€                        SpeedRange = (MaxSpeed * 2) / (DPoints * 3)€                    }€                    TorqueArray:pushNumber(clamp(AvgTorqueOut, 0, 9e15))€                    RSDArray:pushNumber(RSD - PIDRSD)€                    OpSpeed -= SpeedStep€                } elseif (OpSpeed > MaxLMinSpeed) {€                    if (TorqueArray:count() > 1) { €                        TorqueArray:pushNumber(0)€                        RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                        OpSpeed -= SpeedStep€                    } else {OpSpeed -= SpeedStep}€                } €                if ((OpSpeed + SpeedStep < MaxLMinSpeed & AvgTorqueOut < 0) | OpSpeed <= 0) {€                    MinSpeed = clamp(OpSpeed, 0, 9e15) €                    Timer1 = 0€                    Phase = 5€                    TorqueArray:pushNumber(clamp(AvgTorqueOut, 0, 9e15)) €                    RSDArray:pushNumber(clamp(RSD - PIDRSD, 0, 9e15))€                }€            }€                                    €                    €        } elseif (Phase == 5) {# inertia test€            if (changed(Phase)) {€                IStartIndex = floor(TorqueArray:count() * 2 / 3) - 1€                IEndIndex = floor(TorqueArray:count() / 3) - 1€                IStartSpeed = MaxSpeed - IStartIndex * SpeedStep€                IEndSpeed = MaxSpeed - IEndIndex * SpeedStep€                OpSpeed = IStartSpeed # start inertia test at 1/3 engine operating speed, make sure this is on an increment€                Timer2 = -T * 4 # big PID response needed€            }€            if (abs(AvgAcc) < 0.25 & inrange(AvgSpeed, OpSpeed - SpeedStep / 2, OpSpeed + SpeedStep / 2)) { # wait until start speed is correct€                Phase = 6€                Progress = 0.98€            }€            if (Timer2 > 20 * T) {€                ErrorString = £Error: Inertia test failed£€                hint(ErrorString, 7)€                ErrorArray:pushString(ErrorString)€                hint(£Test Complete£, 7)€                owner():soundPlay(0, 1, £buttons/bell1.wav£)€                Phase = 8€                Progress = 1€                PrintErrors = 1€                I = 1€            }€        }€    } €    if (changed(OpSpeed) & Phase == 4) { # if a maxSpeed has been found€        if (MaxSpeed) {€            Progress = (0.04 + clamp((1 - OpSpeed / MaxSpeed)^1.5, 0, 1) * 0.96) * 0.96€        }€        Timer2 = Timer1 = 0€    }€    €        # then turn off pid control and time how long it takes to get to operating speed * 2/3€        # divide acceleration by average torque output for that period to give inertia€€} elseif (Phase == 6) {€Timer1++€Timer5++€if (Timer5 > T * 30) {€    ErrorString = £Error: Failed to find inertia£€    hint(ErrorString, 7)€    ErrorArray:pushString(ErrorString)€    owner():soundPlay(0, 1, £buttons/button10.wav£)€    hint(£Test Complete£, 7)€    Phase = 8 # test finished€    Progress = 1€    PrintErrors = 1€    I = 1€}€    if (abs(Speed) >= IEndSpeed) {€        Phase = 7€    }€} elseif (Phase == 7) {€    IAcceleration = (IEndSpeed - IStartSpeed) / (Timer1 / T) # a = dv/dt€    for (Loop2 = IStartIndex, IEndIndex, -1) {€        SumITorque += TorqueArray[Loop2, number]€    }€    ITorque = SumITorque / (IStartIndex - IEndIndex) # average torque over test interval€    Inertia = (ITorque / IAcceleration) - (Rotor:inertia():z() * 1550.1) # I = T / a€    hint(£Test Complete£, 7)€    owner():soundPlay(0, 1, £buttons/bell1.wav£)€    Phase = 8 # test finished€    Progress = 1€    PrintErrors = 1€    I = 1€}€€if (PrintErrors) {€    if (changed(PrintErrors)) {print(2, £---------------------------------------------------------------------£)}€    for (Loop3 = I, I + 5) {€        print(2, ErrorArray[Loop3, string])€    }€    I += 5€    if (I > ErrorArray:count()) {€        TestIncrementsS = (TorqueArray:count()):toString()€        print(2, £Completed £ + TestIncrementsS + £/£ + (DPoints + 1):toString() + £ increments, testing finished£)€        print(2, £---------------------------------------------------------------------£)€        PrintErrors = 0€        exit()€        }€}€# By Tolyzor€# Please do not copy or modify this code, if you would like to use an aspect of it, please contact me at wiremod.com€#€# Contact for support at wiremod.com€"
180:"Entity"
181:"$Error"
182:"PIDRSD"
183:"PrintErrors"
184:"IStartSpeed"
185:"TorqueClamp"
186:"ErrorArray"
187:"IStartIndex"
188:"ITorque"
189:"Momentum"
190:"Loop3"
191:"TorqueOut"
192:"IEndSpeed"
193:"$Speed"
194:"SumAcc"
195:"ErrorString"
196:"Drag"
197:"Time"
198:"SumSpeed"
199:"Rotations"
200:"IEndIndex"
201:"Loop1"
202:"SumITorque"
203:"SpeedRange"
204:"RotorMass"
205:"Loop2"
206:"IAcceleration"
207:"SumDev"
208:"nocollide"
209:"gmod_wire_emarker"
210:"models/jaanus/wiretool/wiretool_range.mdl"
211:"mark"
212:"Server physics info 2"
213:"@name Server physics info 2€@outputs TickRate AirDensity Gravity MaxAngSpeed MaxSpeed €# Tick rate finding€@persist CurTime Timer1 TickArray:array €€@persist Complete€runOnTick(!Complete)€interval(2e3) # check everything other than tickrate every 2 seconds€if (duped()) {reset()}€AirDensity = airDensity()€Gravity = propGravity():z()€MaxAngSpeed = toRad(angSpeedLimit())€MaxSpeed = speedLimit()€€# Tickrate finding€if (!TickRate) { # tickrate can only be changed with a server restart€    CurTime = curtime()€    Timer1++€    if (Timer1 > 2) { # wait 1 tick for duped e2 to activate, 1 tick for delta to normalise€    TickArray:pushNumber($CurTime)€        if (Timer1 >= 102) {€            TickRate = 1 / TickArray:average()  # tick rate is average of 100 delta curtimes€            MaxT = 1 / TickArray:min()€            MinT = 1 / TickArray:max()€            if ((MaxT - MinT) / TickRate > 0.2) { # is tick rate variance more than 20% ?€                hint(£Warning: Excessive server lag£, 7)€            }€            if (inrange(TickRate, 15, 45)) {TickRate = 32.985} # tick rate 33 server€            elseif (inrange(TickRate, 46, 84)) {TickRate = 66.566669} # tick rate 66 server€            elseif (inrange(TickRate, 85, 115)) {TickRate = 99.85} # tick rate 100 server€            else {hint(£Error: Tick rate not found£, 7)}€            Complete = 1€        }€    }€}€€€"
214:"$CurTime"
215:"CurTime"
216:"Complete"
217:"MaxT"
218:"TickArray"
219:"MinT"
220:"forcelimit"
221:"Index"
222:"Bone"
223:"deleteonbreak"
224:"Weld"
225:"Type"
226:"NoCollide"
227:"friction"
228:"torquelimit"
229:"LPos2"
230:"LPos"
231:"Axis"
232:"LPos1"
233:"LocalAxis"
Saved:537